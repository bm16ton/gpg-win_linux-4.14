--- drivers/acpi/ec.c	2019-04-05 16:31:40.000000000 -0400
+++ drivers/acpi/ec.c	2019-11-22 06:58:54.047326834 -0500
@@ -486,11 +486,8 @@
 {
 	if (!test_and_set_bit(EC_FLAGS_QUERY_ENABLED, &ec->flags))
 		ec_log_drv("event unblocked");
-	/*
-	 * Unconditionally invoke this once after enabling the event
-	 * handling mechanism to detect the pending events.
-	 */
-	advance_transaction(ec);
+	if (!test_bit(EC_FLAGS_QUERY_PENDING, &ec->flags))
+		advance_transaction(ec);
 }
 
 static inline void __acpi_ec_disable_event(struct acpi_ec *ec)
@@ -1569,6 +1566,7 @@
 	struct acpi_table_ecdt *ecdt_ptr;
 	acpi_status status;
 	acpi_handle handle;
+	int ret;
 
 	status = acpi_get_table(ACPI_SIG_ECDT, 1,
 				(struct acpi_table_header **)&ecdt_ptr);
@@ -1598,7 +1596,6 @@
 	struct acpi_ec *ec = NULL;
 	int ret;
 	bool is_ecdt = false;
-	acpi_status status;
 
 	strcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_EC_CLASS);
@@ -1606,37 +1603,37 @@
 	if (!strcmp(acpi_device_hid(device), ACPI_ECDT_HID)) {
 		is_ecdt = true;
 		ec = boot_ec;
-	} else {
-		ec = acpi_ec_alloc();
-		if (!ec)
-			return -ENOMEM;
-		status = ec_parse_device(device->handle, 0, ec, NULL);
-		if (status != AE_CTRL_TERMINATE) {
+		goto end;
+	}
+
+	ec = acpi_ec_alloc();
+	if (!ec)
+		return -ENOMEM;
+	if (ec_parse_device(device->handle, 0, ec, NULL) !=
+		AE_CTRL_TERMINATE) {
 			ret = -EINVAL;
 			goto err_alloc;
-		}
 	}
 
 	if (acpi_is_boot_ec(ec)) {
-		boot_ec_is_ecdt = is_ecdt;
-		if (!is_ecdt) {
-			/*
-			 * Trust PNP0C09 namespace location rather than
-			 * ECDT ID. But trust ECDT GPE rather than _GPE
-			 * because of ASUS quirks, so do not change
-			 * boot_ec->gpe to ec->gpe.
-			 */
-			boot_ec->handle = ec->handle;
-			acpi_handle_debug(ec->handle, "duplicated.\n");
-			acpi_ec_free(ec);
-			ec = boot_ec;
-		}
-		ret = acpi_config_boot_ec(ec, ec->handle, true, is_ecdt);
+		boot_ec_is_ecdt = false;
+		/*
+		 * Trust PNP0C09 namespace location rather than ECDT ID.
+		 *
+		 * But trust ECDT GPE rather than _GPE because of ASUS quirks,
+		 * so do not change boot_ec->gpe to ec->gpe.
+		 */
+		boot_ec->handle = ec->handle;
+		acpi_handle_debug(ec->handle, "duplicated.\n");
+		acpi_ec_free(ec);
+		ec = boot_ec;
+		ret = acpi_config_boot_ec(ec, ec->handle, true, false);
 	} else
 		ret = acpi_ec_setup(ec, true);
 	if (ret)
 		goto err_query;
 
+end:
 	device->driver_data = ec;
 
 	ret = !!request_region(ec->data_addr, 1, "EC data");
@@ -1762,6 +1759,7 @@
 static int __init acpi_ec_ecdt_start(void)
 {
 	acpi_handle handle;
+	int ret;
 
 	if (!boot_ec)
 		return -ENODEV;
@@ -1776,11 +1774,13 @@
 	 * Note: ec->handle can be valid if this function is called after
 	 * acpi_ec_add(), hence the fast path.
 	 */
-	if (boot_ec->handle == ACPI_ROOT_OBJECT) {
-		if (!acpi_ec_ecdt_get_handle(&handle))
-			return -ENODEV;
-		boot_ec->handle = handle;
-	}
+	if (boot_ec->handle != ACPI_ROOT_OBJECT)
+		handle = boot_ec->handle;
+	else if (!acpi_ec_ecdt_get_handle(&handle))
+		return -ENODEV;
+	ret = acpi_config_boot_ec(boot_ec, handle, true, true);
+	if (ret)
+		return ret;
 
 	/* Register to ACPI bus with PM ops attached */
 	return acpi_bus_register_early_device(ACPI_BUS_TYPE_ECDT_EC);
