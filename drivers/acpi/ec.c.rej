--- drivers/acpi/ec.c	2017-12-28 22:39:18.048148186 -0500
+++ drivers/acpi/ec.c	2017-12-28 22:42:22.685437483 -0500
@@ -1595,7 +1592,6 @@
 	struct acpi_ec *ec = NULL;
 	int ret;
 	bool is_ecdt = false;
-	acpi_status status;
 
 	strcpy(acpi_device_name(device), ACPI_EC_DEVICE_NAME);
 	strcpy(acpi_device_class(device), ACPI_EC_CLASS);
@@ -1603,37 +1599,37 @@
 	if (!strcmp(acpi_device_hid(device), ACPI_ECDT_HID)) {
 		is_ecdt = true;
 		ec = boot_ec;
-	} else {
-		ec = acpi_ec_alloc();
-		if (!ec)
-			return -ENOMEM;
-		status = ec_parse_device(device->handle, 0, ec, NULL);
-		if (status != AE_CTRL_TERMINATE) {
+		goto end;
+	}
+
+	ec = acpi_ec_alloc();
+	if (!ec)
+		return -ENOMEM;
+	if (ec_parse_device(device->handle, 0, ec, NULL) !=
+		AE_CTRL_TERMINATE) {
 			ret = -EINVAL;
 			goto err_alloc;
-		}
 	}
 
 	if (acpi_is_boot_ec(ec)) {
-		boot_ec_is_ecdt = is_ecdt;
-		if (!is_ecdt) {
-			/*
-			 * Trust PNP0C09 namespace location rather than
-			 * ECDT ID. But trust ECDT GPE rather than _GPE
-			 * because of ASUS quirks, so do not change
-			 * boot_ec->gpe to ec->gpe.
-			 */
-			boot_ec->handle = ec->handle;
-			acpi_handle_debug(ec->handle, "duplicated.\n");
-			acpi_ec_free(ec);
-			ec = boot_ec;
-		}
-		ret = acpi_config_boot_ec(ec, ec->handle, true, is_ecdt);
+		boot_ec_is_ecdt = false;
+		/*
+		 * Trust PNP0C09 namespace location rather than ECDT ID.
+		 *
+		 * But trust ECDT GPE rather than _GPE because of ASUS quirks,
+		 * so do not change boot_ec->gpe to ec->gpe.
+		 */
+		boot_ec->handle = ec->handle;
+		acpi_handle_debug(ec->handle, "duplicated.\n");
+		acpi_ec_free(ec);
+		ec = boot_ec;
+		ret = acpi_config_boot_ec(ec, ec->handle, true, false);
 	} else
 		ret = acpi_ec_setup(ec, true);
 	if (ret)
 		goto err_query;
 
+end:
 	device->driver_data = ec;
 
 	ret = !!request_region(ec->data_addr, 1, "EC data");
@@ -1774,11 +1771,13 @@
 	 * Note: ec->handle can be valid if this function is called after
 	 * acpi_ec_add(), hence the fast path.
 	 */
-	if (boot_ec->handle == ACPI_ROOT_OBJECT) {
-		if (!acpi_ec_ecdt_get_handle(&handle))
-			return -ENODEV;
-		boot_ec->handle = handle;
-	}
+	if (boot_ec->handle != ACPI_ROOT_OBJECT)
+		handle = boot_ec->handle;
+	else if (!acpi_ec_ecdt_get_handle(&handle))
+		return -ENODEV;
+	ret = acpi_config_boot_ec(boot_ec, handle, true, true);
+	if (ret)
+		return ret;
 
 	/* Register to ACPI bus with PM ops attached */
 	return acpi_bus_register_early_device(ACPI_BUS_TYPE_ECDT_EC);
