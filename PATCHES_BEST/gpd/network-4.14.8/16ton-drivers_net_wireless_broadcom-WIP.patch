diff -Naur ../linux-sunxi-4.14-footrail/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c
--- ../linux-sunxi-4.14-footrail/drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c	2017-11-20 03:23:35.000000000 -0500
+++ drivers/net/wireless/broadcom/brcm80211/brcmfmac/cfg80211.c	2017-12-17 16:29:08.146128011 -0500
@@ -151,6 +151,7 @@
 }
 
 static struct ieee80211_channel __wl_2ghz_channels[] = {
+	CHAN2G(-3, 2392), CHAN2G(-2, 2397), CHAN2G(-1, 2402), CHAN2G(0, 2407),
 	CHAN2G(1, 2412), CHAN2G(2, 2417), CHAN2G(3, 2422), CHAN2G(4, 2427),
 	CHAN2G(5, 2432), CHAN2G(6, 2437), CHAN2G(7, 2442), CHAN2G(8, 2447),
 	CHAN2G(9, 2452), CHAN2G(10, 2457), CHAN2G(11, 2462), CHAN2G(12, 2467),
@@ -193,16 +194,16 @@
 	.alpha2 =  "99",
 	.reg_rules = {
 		/* IEEE 802.11b/g, channels 1..11 */
-		REG_RULE(2412-10, 2472+10, 40, 6, 20, 0),
+		REG_RULE(2312-10, 2484+10, 40, 6, 30, 0),
 		/* If any */
 		/* IEEE 802.11 channel 14 - Only JP enables
 		 * this and for 802.11b only
 		 */
-		REG_RULE(2484-10, 2484+10, 20, 6, 20, 0),
+		REG_RULE(2484-10, 2484+10, 40, 6, 30, 0),
 		/* IEEE 802.11a, channel 36..64 */
-		REG_RULE(5150-10, 5350+10, 80, 6, 20, 0),
+		REG_RULE(4900-10, 5470+10, 80, 6, 30, 0),
 		/* IEEE 802.11a, channel 100..165 */
-		REG_RULE(5470-10, 5850+10, 80, 6, 20, 0), }
+		REG_RULE(4900-10, 6000+10, 80, 6, 30, 0), }
 };
 
 /* Note: brcmf_cipher_suites is an array of int defining which cipher suites
@@ -6110,15 +6111,7 @@
 			chaninfo = ch.chspec;
 			err = brcmf_fil_bsscfg_int_get(ifp, "per_chan_info",
 						       &chaninfo);
-			if (!err) {
-				if (chaninfo & WL_CHAN_RADAR)
-					channel->flags |=
-						(IEEE80211_CHAN_RADAR |
-						 IEEE80211_CHAN_NO_IR);
-				if (chaninfo & WL_CHAN_PASSIVE)
-					channel->flags |=
-						IEEE80211_CHAN_NO_IR;
-			}
+
 		}
 	}
 
@@ -6918,9 +6911,9 @@
 	int i;
 
 	/* The country code gets set to "00" by default at boot, ignore */
-	if (req->alpha2[0] == '0' && req->alpha2[1] == '0')
-		return;
-
+/*	if (req->alpha2[0] == '0' && req->alpha2[1] == '0')
+		return;  
+16ton	*/
 	/* ignore non-ISO3166 country codes */
 	for (i = 0; i < sizeof(req->alpha2); i++)
 		if (req->alpha2[i] < 'A' || req->alpha2[i] > 'Z') {
