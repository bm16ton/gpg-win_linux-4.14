diff -Naur drivers/net/wireless/ath/ath9k/ar9003_eeprom.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c
--- drivers/net/wireless/ath/ath9k/ar9003_eeprom.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/ar9003_eeprom.c	2017-12-10 09:20:16.000893850 -0500
@@ -5503,9 +5503,212 @@
 	return ah->eeprom.map4k.baseEepHeader.eepMisc;
 }

+static u32 ath9k_hw_ar9003_dump_eep_power(struct ath_hw *ah, u8 *buf,
+					  u32 len, u32 size)
+{
+	struct ar9300_eeprom *eep = &ah->eeprom.ar9300_eep;
+	int i, j;
+#define PR_EEP(_s, _val)						\
+	do {								\
+		len += snprintf(buf + len, size - len, _s, (_val));	\
+	} while (0)
+
+	PR_EEP("macAddr : %pM\n", eep->macAddr);
+	len += snprintf(buf + len, size - len, "calPierData2G :\n");
+	len += snprintf(buf + len, size - len,
+			"Chain  refPower voltMeas tempMeas "
+			"rxNoisefloorCal rxNoisefloorPower rxTempMeas\n");
+	for (i = 0; i < AR9300_MAX_CHAINS; i++) {
+		if (!(ah->txchainmask & BIT(i)))
+			continue;
+
+		for (j = 0; j < AR9300_NUM_2G_CAL_PIERS; j++) {
+			len += snprintf(buf + len, size - len,
+				"%2d %8d %8d %10d %10d %20d %8d\n", i,
+				eep->calPierData2G[i][j].refPower,
+				eep->calPierData2G[i][j].voltMeas,
+				eep->calPierData2G[i][j].tempMeas,
+				eep->calPierData2G[i][j].rxNoisefloorCal,
+				eep->calPierData2G[i][j].rxNoisefloorPower,
+				eep->calPierData2G[i][j].rxTempMeas);
+		}
+	}
+	len += snprintf(buf + len, size - len, "\ncalTarget_freqbin_Cck :\n");
+	for (i = 0; i < AR9300_NUM_2G_CCK_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_Cck[i], 1));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len, "\ncalTarget_freqbin_2G :\n");
+	for (i = 0; i < AR9300_NUM_2G_20_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_2G[i], 1));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len,
+			"\ncalTarget_freqbin_2GHT20 :\n");
+	for (i = 0; i < AR9300_NUM_2G_20_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_2GHT20[i], 1));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len,
+			"\ncalTarget_freqbin_2GHT40 :\n");
+	for (i = 0; i < AR9300_NUM_2G_40_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_2GHT40[i], 1));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPowerCck :\n");
+	for (i = 0; i < AR9300_NUM_2G_CCK_TARGET_POWERS; i++) {
+		for (j = 0; j < 4; j++)
+			PR_EEP("%u ", (eep->calTargetPowerCck[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower2G :\n");
+	for (i = 0; i < AR9300_NUM_2G_20_TARGET_POWERS; i++) {
+		for (j = 0; j < 4; j++)
+			PR_EEP("%u ", (eep->calTargetPower2G[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower2GHT20 :\n");
+	for (i = 0; i < AR9300_NUM_2G_20_TARGET_POWERS; i++) {
+		for (j = 0; j < 14; j++)
+			PR_EEP("%u ",
+			       (eep->calTargetPower2GHT20[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower2GHT40 :\n");
+	for (i = 0; i < AR9300_NUM_2G_40_TARGET_POWERS; i++) {
+		for (j = 0; j < 14; j++)
+			PR_EEP("%u ",
+			       (eep->calTargetPower2GHT40[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\nctlIndex_2G :\n");
+	for (i = 0; i < AR9300_NUM_CTLS_2G; i++)
+		PR_EEP("0x%x ", eep->ctlIndex_2G[i]);
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len, "\nctl_freqbin_2G:\n");
+	for (i = 0; i < AR9300_NUM_CTLS_2G; i++) {
+		for (j = 0; j < AR9300_NUM_BAND_EDGES_2G; j++)
+			PR_EEP("%u ", FBIN2FREQ(eep->ctl_freqbin_2G[i][j], 1));
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len,
+			"\nctlPowerData_2G : { power, flag }\n");
+	for (i = 0; i < AR9300_NUM_CTLS_2G; i++) {
+		for (j = 0; j < AR9300_NUM_BAND_EDGES_2G; j++) {
+			len += snprintf(buf + len, size - len, "{ %d, %u } ",
+			   CTL_EDGE_TPOWER(eep->ctlPowerData_2G[i].ctlEdges[j]),
+			   CTL_EDGE_FLAGS(eep->ctlPowerData_2G[i].ctlEdges[j]));
+		}
+		len += snprintf(buf + len, size - len, "\n");
+	}
+	len += snprintf(buf + len, size - len, "\ncalPierData5G :\n");
+	len += snprintf(buf + len, size - len,
+			"Chain  refPower voltMeas tempMeas "
+			"rxNoisefloorCal rxNoisefloorPower rxTempMeas\n");
+	for (i = 0; i < AR9300_MAX_CHAINS; i++) {
+		if (!(ah->txchainmask & BIT(i)))
+			continue;
+
+		for (j = 0; j < AR9300_NUM_5G_CAL_PIERS; j++) {
+			len += snprintf(buf + len, size - len,
+				"%2d %8d %8d %10d %10d %20d %8d\n", i,
+				eep->calPierData5G[i][j].refPower,
+				eep->calPierData5G[i][j].voltMeas,
+				eep->calPierData5G[i][j].tempMeas,
+				eep->calPierData5G[i][j].rxNoisefloorCal,
+				eep->calPierData5G[i][j].rxNoisefloorPower,
+				eep->calPierData5G[i][j].rxTempMeas);
+		}
+	}
+	len += snprintf(buf + len, size - len, "\ncalTarget_freqbin_5G :\n");
+	for (i = 0; i < AR9300_NUM_5G_20_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_5G[i], 0));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len,
+			"\ncalTarget_freqbin_5GHT20 :\n");
+	for (i = 0; i < AR9300_NUM_5G_20_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_5GHT20[i], 0));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len,
+			"\ncalTarget_freqbin_5GHT40 :\n");
+	for (i = 0; i < AR9300_NUM_5G_40_TARGET_POWERS; i++)
+		PR_EEP("%u ", FBIN2FREQ(eep->calTarget_freqbin_5GHT40[i], 0));
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower5G :\n");
+	for (i = 0; i < AR9300_NUM_5G_20_TARGET_POWERS; i++) {
+		for (j = 0; j < 4; j++)
+			PR_EEP("%u ", (eep->calTargetPower5G[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower5GHT20 :\n");
+	for (i = 0; i < AR9300_NUM_5G_20_TARGET_POWERS; i++) {
+		for (j = 0; j < 14; j++)
+			PR_EEP("%u ",
+			       (eep->calTargetPower5GHT20[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\ncalTargetPower5GHT40 :\n");
+	for (i = 0; i < AR9300_NUM_5G_40_TARGET_POWERS; i++) {
+		for (j = 0; j < 14; j++)
+			PR_EEP("%u ",
+			       (eep->calTargetPower5GHT40[i].tPow2x[j])/2);
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len, "\nctlIndex_5G :\n");
+	for (i = 0; i < AR9300_NUM_CTLS_5G; i++)
+		PR_EEP("0x%x ", eep->ctlIndex_5G[i]);
+	len += snprintf(buf + len, size - len, "\n");
+
+	len += snprintf(buf + len, size - len, "\nctl_freqbin_5G:\n");
+	for (i = 0; i < AR9300_NUM_CTLS_5G; i++) {
+		for (j = 0; j < AR9300_NUM_BAND_EDGES_5G; j++)
+			PR_EEP("%u ", FBIN2FREQ(eep->ctl_freqbin_5G[i][j], 0));
+		len += snprintf(buf + len, size - len, "\n");
+	}
+
+	len += snprintf(buf + len, size - len,
+			"\nctlPowerData_5G : { power, flag }\n");
+	for (i = 0; i < AR9300_NUM_CTLS_5G; i++) {
+		for (j = 0; j < AR9300_NUM_BAND_EDGES_5G; j++) {
+			len += snprintf(buf + len, size - len, "{ %d, %u } ",
+			   CTL_EDGE_TPOWER(eep->ctlPowerData_5G[i].ctlEdges[j]),
+			   CTL_EDGE_FLAGS(eep->ctlPowerData_5G[i].ctlEdges[j]));
+		}
+		len += snprintf(buf + len, size - len, "\n");
+	}
+	len += snprintf(buf + len, size - len, "\n");
+
+	if (ah->curchan)
+		PR_EEP("freq %d\n", ah->curchan->channel);
+
+	for (i = 0; i < 12; i++)
+		len += snprintf(buf + len, size - len,
+				"Tx Power Rate %2d : 0x%08x\n",
+				i, REG_READ(ah, AR_PHY_POWER_TX_RATE(i)));
+
+	if (len > size)
+		len = size;
+
+#undef PR_EEP
+	return len;
+}
+
 const struct eeprom_ops eep_ar9300_ops = {
 	.check_eeprom = ath9k_hw_ar9300_check_eeprom,
 	.get_eeprom = ath9k_hw_ar9300_get_eeprom,
+	.dump_eep_power = ath9k_hw_ar9003_dump_eep_power,
 	.fill_eeprom = ath9k_hw_ar9300_fill_eeprom,
 	.dump_eeprom = ath9k_hw_ar9003_dump_eeprom,
 	.get_eeprom_ver = ath9k_hw_ar9300_get_eeprom_ver,
diff -Naur drivers/net/wireless/ath/ath9k/common-init.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/common-init.c
--- drivers/net/wireless/ath/ath9k/common-init.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/common-init.c	2017-12-10 09:20:16.004227179 -0500
@@ -22,14 +22,14 @@
 	.band = NL80211_BAND_2GHZ, \
 	.center_freq = (_freq), \
 	.hw_value = (_idx), \
-	.max_power = 20, \
+	.max_power = 30, \
 }

 #define CHAN5G(_freq, _idx) { \
 	.band = NL80211_BAND_5GHZ, \
 	.center_freq = (_freq), \
 	.hw_value = (_idx), \
-	.max_power = 20, \
+	.max_power = 30, \
 }

 /* Some 2 GHz radios are actually tunable on 2312-2732
@@ -37,6 +37,27 @@
  * we have calibration data for all cards though to make
  * this static */
 static const struct ieee80211_channel ath9k_2ghz_chantable[] = {
+	CHAN2G(2312, 26), /* Channel XX */
+	CHAN2G(2317, 27), /* Channel XX */
+	CHAN2G(2322, 28), /* Channel XX */
+	CHAN2G(2327, 29), /* Channel XX */
+	CHAN2G(2332, 30), /* Channel XX */
+	CHAN2G(2337, 31), /* Channel XX */
+	CHAN2G(2342, 32), /* Channel XX */
+	CHAN2G(2347, 33), /* Channel XX */
+	CHAN2G(2352, 34), /* Channel XX */
+	CHAN2G(2357, 35), /* Channel XX */
+	CHAN2G(2362, 36), /* Channel XX */
+	CHAN2G(2367, 37), /* Channel XX */
+	CHAN2G(2372, 38), /* Channel XX */
+	CHAN2G(2377, 39), /* Channel XX */
+	CHAN2G(2382, 40), /* Channel XX */
+	CHAN2G(2387, 41), /* Channel XX */
+	CHAN2G(2392, 42), /* Channel XX */
+	CHAN2G(2397, 43), /* Channel XX */
+	CHAN2G(2402, 44), /* Channel XX */
+	CHAN2G(2407, 45), /* Channel XX */
+
 	CHAN2G(2412, 0), /* Channel 1 */
 	CHAN2G(2417, 1), /* Channel 2 */
 	CHAN2G(2422, 2), /* Channel 3 */
@@ -50,7 +71,23 @@
 	CHAN2G(2462, 10), /* Channel 11 */
 	CHAN2G(2467, 11), /* Channel 12 */
 	CHAN2G(2472, 12), /* Channel 13 */
+
+
 	CHAN2G(2484, 13), /* Channel 14 */
+
+	CHAN2G(2487, 14), /* Channel XX */
+	CHAN2G(2502, 15), /* Channel XX */
+	CHAN2G(2512, 16), /* Channel XX */
+	CHAN2G(2572, 17), /* Channel XX */
+	CHAN2G(2592, 18), /* Channel XX */
+	CHAN2G(2612, 19), /* Channel XX */
+	CHAN2G(2632, 20), /* Channel XX */
+	CHAN2G(2652, 21), /* Channel XX */
+	CHAN2G(2672, 22), /* Channel XX */
+	CHAN2G(2692, 23), /* Channel XX */
+	CHAN2G(2712, 24), /* Channel XX */
+	CHAN2G(2732, 25), /* Channel XX */
+
 };

 /* Some 5 GHz radios are actually tunable on XXXX-YYYY
@@ -58,34 +95,39 @@
  * we have calibration data for all cards though to make
  * this static */
 static const struct ieee80211_channel ath9k_5ghz_chantable[] = {
+	CHAN5G(4920, 46), /* Channel XX */
+	CHAN5G(4940, 47), /* Channel XX */
+	CHAN5G(4960, 48), /* Channel XX */
+	CHAN5G(4980, 49), /* Channel XX */
+
 	/* _We_ call this UNII 1 */
-	CHAN5G(5180, 14), /* Channel 36 */
-	CHAN5G(5200, 15), /* Channel 40 */
-	CHAN5G(5220, 16), /* Channel 44 */
-	CHAN5G(5240, 17), /* Channel 48 */
+	CHAN5G(5180, 50), /* Channel 36 */
+	CHAN5G(5200, 51), /* Channel 40 */
+	CHAN5G(5220, 52), /* Channel 44 */
+	CHAN5G(5240, 53), /* Channel 48 */
 	/* _We_ call this UNII 2 */
-	CHAN5G(5260, 18), /* Channel 52 */
-	CHAN5G(5280, 19), /* Channel 56 */
-	CHAN5G(5300, 20), /* Channel 60 */
-	CHAN5G(5320, 21), /* Channel 64 */
+	CHAN5G(5260, 54), /* Channel 52 */
+	CHAN5G(5280, 55), /* Channel 56 */
+	CHAN5G(5300, 56), /* Channel 60 */
+	CHAN5G(5320, 57), /* Channel 64 */
 	/* _We_ call this "Middle band" */
-	CHAN5G(5500, 22), /* Channel 100 */
-	CHAN5G(5520, 23), /* Channel 104 */
-	CHAN5G(5540, 24), /* Channel 108 */
-	CHAN5G(5560, 25), /* Channel 112 */
-	CHAN5G(5580, 26), /* Channel 116 */
-	CHAN5G(5600, 27), /* Channel 120 */
-	CHAN5G(5620, 28), /* Channel 124 */
-	CHAN5G(5640, 29), /* Channel 128 */
-	CHAN5G(5660, 30), /* Channel 132 */
-	CHAN5G(5680, 31), /* Channel 136 */
-	CHAN5G(5700, 32), /* Channel 140 */
+	CHAN5G(5500, 58), /* Channel 100 */
+	CHAN5G(5520, 59), /* Channel 104 */
+	CHAN5G(5540, 60), /* Channel 108 */
+	CHAN5G(5560, 61), /* Channel 112 */
+	CHAN5G(5580, 62), /* Channel 116 */
+	CHAN5G(5600, 63), /* Channel 120 */
+	CHAN5G(5620, 64), /* Channel 124 */
+	CHAN5G(5640, 65), /* Channel 128 */
+	CHAN5G(5660, 66), /* Channel 132 */
+	CHAN5G(5680, 67), /* Channel 136 */
+	CHAN5G(5700, 68), /* Channel 140 */
 	/* _We_ call this UNII 3 */
-	CHAN5G(5745, 33), /* Channel 149 */
-	CHAN5G(5765, 34), /* Channel 153 */
-	CHAN5G(5785, 35), /* Channel 157 */
-	CHAN5G(5805, 36), /* Channel 161 */
-	CHAN5G(5825, 37), /* Channel 165 */
+	CHAN5G(5745, 69), /* Channel 149 */
+	CHAN5G(5765, 70), /* Channel 153 */
+	CHAN5G(5785, 71), /* Channel 157 */
+	CHAN5G(5805, 72), /* Channel 161 */
+	CHAN5G(5825, 73), /* Channel 165 */
 };

 /* Atheros hardware rate code addition for short premble */
diff -Naur drivers/net/wireless/ath/ath9k/debug.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/debug.c
--- drivers/net/wireless/ath/ath9k/debug.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/debug.c	2017-12-10 09:20:16.004227179 -0500
@@ -128,6 +128,36 @@

 #define DMA_BUF_LEN 1024

+static ssize_t read_file_dump_eep_power(struct file *file,
+					char __user *user_buf,
+					size_t count, loff_t *ppos)
+{
+	struct ath_softc *sc = file->private_data;
+	struct ath_hw *ah = sc->sc_ah;
+	u32 len = 0, size = 6000;
+	ssize_t retval = 0;
+	char *buf;
+
+	buf = kzalloc(size, GFP_KERNEL);
+	if (!buf)
+		return -ENOMEM;
+
+	ath9k_ps_wakeup(sc);
+	len = ah->eep_ops->dump_eep_power(ah, buf, len, size);
+	ath9k_ps_restore(sc);
+
+	retval = simple_read_from_buffer(user_buf, count, ppos, buf, len);
+	kfree(buf);
+
+	return retval;
+}
+
+static const struct file_operations fops_dump_eep_power = {
+	.read = read_file_dump_eep_power,
+	.open = simple_open,
+	.owner = THIS_MODULE,
+	.llseek = default_llseek,
+};

 static ssize_t read_file_ani(struct file *file, char __user *user_buf,
 			     size_t count, loff_t *ppos)
@@ -1432,7 +1462,8 @@

 	ath9k_cmn_debug_base_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
 	ath9k_cmn_debug_modal_eeprom(sc->debug.debugfs_phy, sc->sc_ah);
-
+	debugfs_create_file("dump_eep_power", S_IRUSR | S_IRGRP | S_IROTH,
+			    sc->debug.debugfs_phy, sc, &fops_dump_eep_power);
 	debugfs_create_u32("gpio_mask", S_IRUSR | S_IWUSR,
 			   sc->debug.debugfs_phy, &sc->sc_ah->gpio_mask);
 	debugfs_create_u32("gpio_val", S_IRUSR | S_IWUSR,
diff -Naur drivers/net/wireless/ath/ath9k/eeprom_4k.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom_4k.c
--- drivers/net/wireless/ath/ath9k/eeprom_4k.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom_4k.c	2017-12-10 09:20:16.007560508 -0500
@@ -18,6 +18,9 @@
 #include "hw.h"
 #include "ar9002_phy.h"

+extern u8 tx_power_man;
+extern u8 thresh62_man;
+
 static int ath9k_hw_4k_get_eeprom_ver(struct ath_hw *ah)
 {
 	u16 version = le16_to_cpu(ah->eeprom.map4k.baseEepHeader.version);
@@ -610,8 +613,12 @@
 	if (test)
 	    return;

-	for (i = 0; i < Ar5416RateSize; i++)
-		ratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;
+	for (i = 0; i < Ar5416RateSize; i++) {
+//		ratesArray[i] -= AR5416_PWR_TABLE_OFFSET_DB * 2;
+		ratesArray[i] = tx_power_man;
+	}
+
+	printk("ATH: TX Power set: %d\n",tx_power_man);

 	ENABLE_REGWRITE_BUFFER(ah);

@@ -982,10 +989,8 @@
 	if (AR_SREV_9271_10(ah))
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL3, AR_PHY_TX_END_TO_A2_RX_ON,
 			      pModal->txEndToRxOn);
-	REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62,
-		      pModal->thresh62);
-	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62,
-		      pModal->thresh62);
+	REG_RMW_FIELD(ah, AR_PHY_CCA, AR9280_PHY_CCA_THRESH62, thresh62_man);
+	REG_RMW_FIELD(ah, AR_PHY_EXT_CCA0, AR_PHY_EXT_CCA0_THRESH62, thresh62_man);

 	if (ath9k_hw_4k_get_eeprom_rev(ah) >= AR5416_EEP_MINOR_VER_2) {
 		REG_RMW_FIELD(ah, AR_PHY_RF_CTL2, AR_PHY_TX_END_DATA_START,
diff -Naur drivers/net/wireless/ath/ath9k/eeprom_9287.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom_9287.c
--- drivers/net/wireless/ath/ath9k/eeprom_9287.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom_9287.c	2017-12-10 09:20:16.007560508 -0500
@@ -18,6 +18,8 @@
 #include "hw.h"
 #include "ar9002_phy.h"

+extern u8 tx_power_man;
+
 #define SIZE_EEPROM_AR9287 (sizeof(struct ar9287_eeprom) / sizeof(u16))

 static int ath9k_hw_ar9287_get_eeprom_ver(struct ath_hw *ah)
@@ -741,8 +743,12 @@
 	if (test)
 		return;

-	for (i = 0; i < Ar5416RateSize; i++)
-		ratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;
+	for (i = 0; i < Ar5416RateSize; i++) {
+//		ratesArray[i] -= AR9287_PWR_TABLE_OFFSET_DB * 2;
+		ratesArray[i] = tx_power_man;
+	}
+
+	printk("ATH: TX Power set: %d\n",tx_power_man);

 	ENABLE_REGWRITE_BUFFER(ah);

diff -Naur drivers/net/wireless/ath/ath9k/eeprom.h ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom.h
--- drivers/net/wireless/ath/ath9k/eeprom.h	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/eeprom.h	2017-12-10 09:20:16.010893837 -0500
@@ -654,6 +654,7 @@
 struct eeprom_ops {
 	int (*check_eeprom)(struct ath_hw *hw);
 	u32 (*get_eeprom)(struct ath_hw *hw, enum eeprom_param param);
+	u32 (*dump_eep_power)(struct ath_hw *hw, u8 *buf, u32 len, u32 size);
 	bool (*fill_eeprom)(struct ath_hw *hw);
 	u32 (*dump_eeprom)(struct ath_hw *hw, bool dump_base_hdr, u8 *buf,
 			   u32 len, u32 size);
diff -Naur drivers/net/wireless/ath/ath9k/hw.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/hw.c
--- drivers/net/wireless/ath/ath9k/hw.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/hw.c	2017-12-10 09:20:16.014227166 -0500
@@ -29,6 +29,7 @@
 #include "ar9003_mci.h"
 #include "ar9003_phy.h"
 #include "ath9k.h"
+#include "../reg.h"

 static bool ath9k_hw_set_reset_reg(struct ath_hw *ah, u32 type);

@@ -37,6 +38,40 @@
 MODULE_SUPPORTED_DEVICE("Atheros 802.11n WLAN cards");
 MODULE_LICENSE("Dual BSD/GPL");

+u8 tx_power_man = 58; //manual power
+u8 cwmin_man = 7;
+u8 cwmax_man = 15;
+u8 aifs_man = 2;
+u8 cck_sifs_man = 10;
+u8 ofdm_sifs_man = 16;
+u8 slottime_man = 9;
+u8 thresh62_man = 28;
+
+module_param_named(txpower,tx_power_man,byte,0444);
+MODULE_PARM_DESC(txpower,"Manual TX power setting, default 58, max 63");
+
+module_param_named(cwmin,cwmin_man,byte,0444);
+MODULE_PARM_DESC(cwmin,"CWMIN setting, 0-255, default 7");
+
+module_param_named(cwmax,cwmax_man,byte,0444);
+MODULE_PARM_DESC(cwmax,"CWMAX setting, 0-255, default 15");
+
+module_param_named(aifs,aifs_man,byte,0444);
+MODULE_PARM_DESC(aifs,"AIFS setting, default 2");
+
+module_param_named(cck_sifs,cck_sifs_man,byte,0444);
+MODULE_PARM_DESC(cck_sifs,"CCK SIFS setting, default 10");
+
+module_param_named(ofdm_sifs,ofdm_sifs_man,byte,0444);
+MODULE_PARM_DESC(ofdm_sifs,"OFDM SIFS setting, default 16");
+
+module_param_named(slottime,slottime_man,byte,0444);
+MODULE_PARM_DESC(slottime,"Slottime setting, default 9");
+
+module_param_named(thresh62,thresh62_man,byte,0444);
+MODULE_PARM_DESC(thresh62,"CCA THRESH62 setting, default 28");
+
+
 static void ath9k_hw_set_clockrate(struct ath_hw *ah)
 {
 	struct ath_common *common = ath9k_hw_common(ah);
@@ -459,7 +494,8 @@
 	ah->power_mode = ATH9K_PM_UNDEFINED;
 	ah->htc_reset_init = true;

-	ah->tpc_enabled = false;
+	/* ar9002 does not support TPC for the moment */
+	ah->tpc_enabled = !!AR_SREV_9300_20_OR_LATER(ah);

 	ah->ani_function = ATH9K_ANI_ALL;
 	if (!AR_SREV_9300_20_OR_LATER(ah))
@@ -1076,7 +1112,8 @@
 	}

 	/* As defined by IEEE 802.11-2007 17.3.8.6 */
-	slottime += 3 * ah->coverage_class;
+//	slottime += 3 * ah->coverage_class;
+	slottime = slottime_man;
 	acktimeout = slottime + sifstime + ack_offset;
 	ctstimeout = acktimeout;

@@ -2915,17 +2952,19 @@
 	struct ath_regulatory *reg = ath9k_hw_regulatory(ah);
 	struct ieee80211_channel *channel;
 	int chan_pwr, new_pwr;
+	u16 ctl = NO_CTL;

 	if (!chan)
 		return;

+	if (!test)
+		ctl = NO_CTL;
+
 	channel = chan->chan;
 	chan_pwr = min_t(int, channel->max_power * 2, MAX_RATE_POWER);
 	new_pwr = min_t(int, chan_pwr, reg->power_limit);

-	ah->eep_ops->set_txpower(ah, chan,
-				 ath9k_regd_get_ctl(reg, chan),
-				 get_antenna_gain(ah, chan), new_pwr, test);
+	ah->eep_ops->set_txpower(ah, chan, ctl, get_antenna_gain(ah, chan), new_pwr, test);
 }

 void ath9k_hw_set_txpowerlimit(struct ath_hw *ah, u32 limit, bool test)
diff -Naur drivers/net/wireless/ath/ath9k/hw.h ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/hw.h
--- drivers/net/wireless/ath/ath9k/hw.h	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/hw.h	2017-12-10 09:20:16.014227166 -0500
@@ -73,7 +73,7 @@

 #define ATH9K_RSSI_BAD			-128

-#define ATH9K_NUM_CHANNELS	38
+#define ATH9K_NUM_CHANNELS	74

 /* Register read/write primitives */
 #define REG_WRITE(_ah, _reg, _val) \
diff -Naur drivers/net/wireless/ath/ath9k/mac.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/mac.c
--- drivers/net/wireless/ath/ath9k/mac.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/mac.c	2017-12-10 09:20:16.017560495 -0500
@@ -18,6 +18,14 @@
 #include "hw-ops.h"
 #include <linux/export.h>

+extern u8 cwmin_man;
+extern u8 cwmax_man;
+extern u8 aifs_man;
+extern u8 cck_sifs;
+extern u8 ofdm_sifs;
+
+
+
 static void ath9k_hw_set_txq_interrupts(struct ath_hw *ah,
 					struct ath9k_tx_queue_info *qi)
 {
@@ -216,7 +224,8 @@
 	if (qinfo->tqi_aifs != ATH9K_TXQ_USEDEFAULT)
 		qi->tqi_aifs = min(qinfo->tqi_aifs, 255U);
 	else
-		qi->tqi_aifs = INIT_AIFS;
+//		qi->tqi_aifs = INIT_AIFS;
+		qi->tqi_aifs = aifs_man;
 	if (qinfo->tqi_cwmin != ATH9K_TXQ_USEDEFAULT) {
 		cw = min(qinfo->tqi_cwmin, 1024U);
 		qi->tqi_cwmin = 1;
diff -Naur drivers/net/wireless/ath/ath9k/tx99.c ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/tx99.c
--- drivers/net/wireless/ath/ath9k/tx99.c	2017-12-22 17:24:17.439896601 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/ath9k/tx99.c	2017-11-20 03:23:35.000000000 -0500
@@ -179,9 +179,6 @@
 	ssize_t len;
 	int r;

-	if (count < 1)
-		return -EINVAL;
-
 	if (sc->cur_chan->nvifs > 1)
 		return -EOPNOTSUPP;

@@ -189,8 +186,6 @@
 	if (copy_from_user(buf, user_buf, len))
 		return -EFAULT;

-	buf[len] = '\0';
-
 	if (strtobool(buf, &start))
 		return -EINVAL;

diff -Naur drivers/net/wireless/ath/Kconfig ../linux-gpd-4.14/drivers/net/wireless/ath/Kconfig
--- drivers/net/wireless/ath/Kconfig	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/Kconfig	2017-12-10 09:20:16.017560495 -0500
@@ -22,6 +22,9 @@

 if WLAN_VENDOR_ATH

+config ATH_USER_REGD
+	bool "Do not enforce EEPROM regulatory restrictions"
+
 config ATH_DEBUG
 	bool "Atheros wireless debugging"
 	---help---
diff -Naur drivers/net/wireless/ath/regd.c ../linux-gpd-4.14/drivers/net/wireless/ath/regd.c
--- drivers/net/wireless/ath/regd.c	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/regd.c	2017-12-10 10:17:22.089023378 -0500
@@ -23,6 +23,12 @@
 #include "regd.h"
 #include "regd_common.h"

+int ath_16ton;
+module_param_named(16ton, ath_16ton, int, 0444);
+MODULE_PARM_DESC(16ton, "Enable ALL bands, increase txpower");
+
+EXPORT_SYMBOL(ath_16ton);
+
 static int __ath_regd_init(struct ath_regulatory *reg);

 /*
@@ -33,22 +39,16 @@
  */

 /* Only these channels all allow active scan on all world regulatory domains */
-#define ATH9K_2GHZ_CH01_11	REG_RULE(2412-10, 2462+10, 40, 0, 20, 0)
+#define ATH9K_2GHZ_CH01_11	REG_RULE(2312-10, 2462+10, 40, 0, 30, 0)

 /* We enable active scan on these a case by case basis by regulatory domain */
-#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR)
-#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2484+10, 40, 0, 20,\
-					 NL80211_RRF_NO_IR | \
-					 NL80211_RRF_NO_OFDM)
+#define ATH9K_2GHZ_CH12_13	REG_RULE(2467-10, 2472+10, 40, 0, 30, 0)
+#define ATH9K_2GHZ_CH14		REG_RULE(2484-10, 2732+10, 40, 0, 30, 0)

 /* We allow IBSS on these on a case by case basis by regulatory domain */
-#define ATH9K_5GHZ_5150_5350	REG_RULE(5150-10, 5350+10, 80, 0, 30,\
-					 NL80211_RRF_NO_IR)
-#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 5850+10, 80, 0, 30,\
-					 NL80211_RRF_NO_IR)
-#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 5850+10, 80, 0, 30,\
-					 NL80211_RRF_NO_IR)
+#define ATH9K_5GHZ_5150_5350	REG_RULE(4920-10, 5350+10, 80, 0, 30, 0)
+#define ATH9K_5GHZ_5470_5850	REG_RULE(5470-10, 6100+10, 80, 0, 30, 0)
+#define ATH9K_5GHZ_5725_5850	REG_RULE(5725-10, 6100+10, 80, 0, 30, 0)

 #define ATH9K_2GHZ_ALL		ATH9K_2GHZ_CH01_11, \
 				ATH9K_2GHZ_CH12_13, \
@@ -77,9 +77,8 @@
 	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	}
 };

@@ -88,8 +87,8 @@
 	.n_reg_rules = 3,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_5GHZ_NO_MIDBAND,
+		ATH9K_2GHZ_ALL,
+		ATH9K_5GHZ_ALL,
 	}
 };

@@ -98,7 +97,7 @@
 	.n_reg_rules = 3,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	}
 };
@@ -108,8 +107,7 @@
 	.n_reg_rules = 4,
 	.alpha2 =  "99",
 	.reg_rules = {
-		ATH9K_2GHZ_CH01_11,
-		ATH9K_2GHZ_CH12_13,
+		ATH9K_2GHZ_ALL,
 		ATH9K_5GHZ_ALL,
 	}
 };
@@ -119,6 +117,9 @@
 	if (IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_CERT_TESTING))
 		return true;

+	if (ath_16ton)
+		return true;
+
 	switch (reg->country_code) {
 	case CTRY_UNITED_STATES:
 	case CTRY_JAPAN1:
@@ -180,7 +181,7 @@
 	case CTRY_JAPAN57:
 	case CTRY_JAPAN58:
 	case CTRY_JAPAN59:
-		return false;
+		return true;
 	}

 	return true;
@@ -190,9 +191,11 @@
 {
 	if (!IS_ENABLED(CONFIG_ATH_REG_DYNAMIC_USER_REG_HINTS))
 		return false;
+	if (ath_16ton)
+		return false;
 	if (!dynamic_country_user_possible(reg))
 		return false;
-	return true;
+	return false;
 }

 static inline bool is_wwr_sku(u16 regd)
@@ -258,9 +261,10 @@
 			      struct ath_regulatory *reg)

 {
-	if (reg->country_code == CTRY_INDIA)
-		return (center_freq >= 5500 && center_freq <= 5700);
-	return (center_freq >= 5260 && center_freq <= 5700);
+//	if (reg->country_code == CTRY_INDIA)
+//		return (center_freq >= 5500 && center_freq <= 5700);
+//	return (center_freq >= 5260 && center_freq <= 5700);
+return 0;
 }

 static void ath_force_clear_no_ir_chan(struct wiphy *wiphy,
@@ -345,6 +349,13 @@
 	struct ieee80211_channel *ch;
 	unsigned int i;

+#ifdef CONFIG_ATH_USER_REGD
+	return;
+#endif
+
+	if (ath_16ton)
+		return;
+
 	for (band = 0; band < NUM_NL80211_BANDS; band++) {
 		if (!wiphy->bands[band])
 			continue;
@@ -378,6 +389,13 @@
 {
 	struct ieee80211_supported_band *sband;

+#ifdef CONFIG_ATH_USER_REGD
+	return;
+#endif
+
+	if (ath_16ton)
+		return;
+
 	sband = wiphy->bands[NL80211_BAND_2GHZ];
 	if (!sband)
 		return;
@@ -407,6 +425,13 @@
 	struct ieee80211_channel *ch;
 	unsigned int i;

+#ifdef CONFIG_ATH_USER_REGD
+	return;
+#endif
+
+	if (ath_16ton)
+		return;
+
 	if (!wiphy->bands[NL80211_BAND_5GHZ])
 		return;

@@ -639,6 +664,14 @@
 	const struct ieee80211_regdomain *regd;

 	wiphy->reg_notifier = reg_notifier;
+
+#ifdef CONFIG_ATH_USER_REGD
+	return 0;
+#endif
+
+	if (ath_16ton)
+		return 0;
+
 	wiphy->regulatory_flags |= REGULATORY_STRICT_REG |
 				   REGULATORY_CUSTOM_REG;

diff -Naur drivers/net/wireless/ath/reg.h ../linux-gpd-4.14/drivers/net/wireless/ath/reg.h
--- drivers/net/wireless/ath/reg.h	2017-11-20 03:23:35.000000000 -0500
+++ ../linux-gpd-4.14/drivers/net/wireless/ath/reg.h	2017-12-10 09:20:16.020893824 -0500
@@ -14,6 +14,7 @@
  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
  */

+extern int ath_16ton;
 #ifndef ATH_REGISTERS_H
 #define ATH_REGISTERS_H

